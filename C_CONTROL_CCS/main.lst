CCS PCM C Compiler, Version 5.101, 43599               06-Dec-21 16:57

               Filename:   C:\Users\Nguyen Truong An\AGV_Project\C_CONTROL_CCS\main.lst

               ROM used:   1850 words (23%)
                           Largest free fragment is 2048
               RAM used:   42 (11%) at main() level
                           66 (18%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   644
0003:  NOP
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
0004:  DATA E5,2F
0005:  DATA 65,37
0006:  DATA 76,10
0007:  DATA 3D,10
0008:  DATA 25,36
0009:  DATA F5,04
000A:  DATA 00,00
000B:  DATA 43,21
000C:  DATA 31,10
000D:  DATA 3D,10
000E:  DATA 25,36
000F:  DATA 75,00
0010:  DATA 43,21
0011:  DATA 32,10
0012:  DATA 3D,10
0013:  DATA 25,36
0014:  DATA 75,00
0015:  DATA 43,21
0016:  DATA 33,10
0017:  DATA 3D,10
0018:  DATA 25,36
0019:  DATA 75,00
001A:  DATA 43,21
001B:  DATA 34,10
001C:  DATA 3D,10
001D:  DATA 25,36
001E:  DATA 75,00
001F:  DATA 43,21
0020:  DATA 35,10
0021:  DATA 3D,10
0022:  DATA 25,36
0023:  DATA 75,00
0024:  DATA 43,21
0025:  DATA 36,10
0026:  DATA 3D,10
0027:  DATA 25,36
0028:  DATA 75,00
0029:  DATA 43,21
002A:  DATA 37,10
002B:  DATA 3D,10
002C:  DATA 25,36
002D:  DATA 75,00
002E:  DATA 4B,34
002F:  DATA EF,30
0030:  DATA EE,33
0031:  DATA A0,31
0032:  DATA E1,31
0033:  DATA 68,10
0034:  DATA 3D,10
0035:  DATA 25,36
0036:  DATA 75,00
*
006E:  MOVLW  10
006F:  MOVWF  5A
0070:  CLRF   77
0071:  CLRF   7A
0072:  RRF    57,F
0073:  RRF    56,F
0074:  BTFSS  03.0
0075:  GOTO   07C
0076:  MOVF   58,W
0077:  ADDWF  77,F
0078:  BTFSC  03.0
0079:  INCF   7A,F
007A:  MOVF   59,W
007B:  ADDWF  7A,F
007C:  RRF    7A,F
007D:  RRF    77,F
007E:  RRF    79,F
007F:  RRF    78,F
0080:  DECFSZ 5A,F
0081:  GOTO   072
0082:  RETURN
0083:  MOVF   0B,W
0084:  MOVWF  55
0085:  BCF    0B.7
0086:  BSF    03.5
0087:  BSF    03.6
0088:  BSF    0C.7
0089:  BSF    0C.0
008A:  NOP
008B:  NOP
008C:  BCF    03.5
008D:  BCF    03.6
008E:  BTFSC  55.7
008F:  BSF    0B.7
0090:  BTFSC  03.0
0091:  GOTO   0BB
0092:  BSF    03.6
0093:  MOVF   0C,W
0094:  ANDLW  7F
0095:  BCF    03.6
0096:  MOVWF  55
0097:  BSF    03.6
0098:  MOVF   0D,W
0099:  BCF    03.6
009A:  MOVWF  56
009B:  BSF    03.6
009C:  MOVF   0F,W
009D:  BCF    03.6
009E:  MOVWF  57
009F:  MOVF   55,W
00A0:  BTFSS  0C.4
00A1:  GOTO   0A0
00A2:  MOVWF  19
00A3:  MOVF   56,W
00A4:  BSF    03.6
00A5:  MOVWF  0D
00A6:  BCF    03.6
00A7:  MOVF   57,W
00A8:  BSF    03.6
00A9:  MOVWF  0F
00AA:  BCF    03.6
00AB:  MOVF   0B,W
00AC:  MOVWF  58
00AD:  BCF    0B.7
00AE:  BSF    03.5
00AF:  BSF    03.6
00B0:  BSF    0C.7
00B1:  BSF    0C.0
00B2:  NOP
00B3:  NOP
00B4:  BCF    03.5
00B5:  BCF    03.6
00B6:  BTFSC  58.7
00B7:  BSF    0B.7
00B8:  DECFSZ 54,F
00B9:  GOTO   0BB
00BA:  GOTO   0DB
00BB:  BSF    03.6
00BC:  RLF    0C,W
00BD:  RLF    0E,W
00BE:  ANDLW  7F
00BF:  BCF    03.6
00C0:  MOVWF  55
00C1:  BSF    03.6
00C2:  MOVF   0D,W
00C3:  BCF    03.6
00C4:  MOVWF  56
00C5:  BSF    03.6
00C6:  MOVF   0F,W
00C7:  BCF    03.6
00C8:  MOVWF  57
00C9:  MOVF   55,W
00CA:  BTFSS  0C.4
00CB:  GOTO   0CA
00CC:  MOVWF  19
00CD:  MOVF   56,W
00CE:  BSF    03.6
00CF:  MOVWF  0D
00D0:  BCF    03.6
00D1:  MOVF   57,W
00D2:  BSF    03.6
00D3:  MOVWF  0F
00D4:  INCF   0D,F
00D5:  BTFSC  03.2
00D6:  INCF   0F,F
00D7:  BCF    03.0
00D8:  BCF    03.6
00D9:  DECFSZ 54,F
00DA:  GOTO   083
00DB:  RETURN
00DC:  CLRF   5C
00DD:  MOVF   04,W
00DE:  MOVWF  5B
00DF:  BCF    5C.0
00E0:  BTFSC  03.7
00E1:  BSF    5C.0
00E2:  SWAPF  55,W
00E3:  IORLW  F0
00E4:  MOVWF  57
00E5:  ADDWF  57,F
00E6:  ADDLW  E2
00E7:  MOVWF  58
00E8:  ADDLW  32
00E9:  MOVWF  5A
00EA:  MOVF   55,W
00EB:  ANDLW  0F
00EC:  ADDWF  58,F
00ED:  ADDWF  58,F
00EE:  ADDWF  5A,F
00EF:  ADDLW  E9
00F0:  MOVWF  59
00F1:  ADDWF  59,F
00F2:  ADDWF  59,F
00F3:  SWAPF  54,W
00F4:  ANDLW  0F
00F5:  ADDWF  59,F
00F6:  ADDWF  5A,F
00F7:  RLF    59,F
00F8:  RLF    5A,F
00F9:  COMF   5A,F
00FA:  RLF    5A,F
00FB:  MOVF   54,W
00FC:  ANDLW  0F
00FD:  ADDWF  5A,F
00FE:  RLF    57,F
00FF:  MOVLW  07
0100:  MOVWF  56
0101:  MOVLW  0A
0102:  ADDWF  5A,F
0103:  DECF   59,F
0104:  BTFSS  03.0
0105:  GOTO   102
0106:  ADDWF  59,F
0107:  DECF   58,F
0108:  BTFSS  03.0
0109:  GOTO   106
010A:  ADDWF  58,F
010B:  DECF   57,F
010C:  BTFSS  03.0
010D:  GOTO   10A
010E:  ADDWF  57,F
010F:  DECF   56,F
0110:  BTFSS  03.0
0111:  GOTO   10E
0112:  MOVLW  56
0113:  MOVWF  04
0114:  BCF    03.7
0115:  MOVLW  07
0116:  ANDWF  5B,W
0117:  BCF    5B.6
0118:  ADDWF  04,F
0119:  MOVLW  5A
011A:  SUBWF  04,W
011B:  BTFSC  03.2
011C:  BSF    5B.6
011D:  MOVF   00,W
011E:  MOVWF  77
011F:  BTFSS  03.2
0120:  GOTO   129
0121:  BTFSC  5B.6
0122:  GOTO   129
0123:  BTFSC  5B.4
0124:  GOTO   131
0125:  BTFSC  5B.3
0126:  GOTO   129
0127:  MOVLW  20
0128:  GOTO   12C
0129:  BSF    5B.3
012A:  BCF    5B.4
012B:  MOVLW  30
012C:  ADDWF  77,F
012D:  MOVF   77,W
012E:  BTFSS  0C.4
012F:  GOTO   12E
0130:  MOVWF  19
0131:  INCF   04,F
0132:  BTFSS  5B.6
0133:  GOTO   119
0134:  RETURN
*
02B2:  CLRF   78
02B3:  CLRF   79
02B4:  CLRF   77
02B5:  CLRF   7A
02B6:  MOVF   5B,W
02B7:  BTFSS  03.2
02B8:  GOTO   2BC
02B9:  MOVF   5A,W
02BA:  BTFSC  03.2
02BB:  GOTO   2D6
02BC:  MOVLW  10
02BD:  MOVWF  5C
02BE:  BCF    03.0
02BF:  RLF    58,F
02C0:  RLF    59,F
02C1:  RLF    77,F
02C2:  RLF    7A,F
02C3:  MOVF   5B,W
02C4:  SUBWF  7A,W
02C5:  BTFSS  03.2
02C6:  GOTO   2C9
02C7:  MOVF   5A,W
02C8:  SUBWF  77,W
02C9:  BTFSS  03.0
02CA:  GOTO   2D2
02CB:  MOVF   5A,W
02CC:  SUBWF  77,F
02CD:  BTFSS  03.0
02CE:  DECF   7A,F
02CF:  MOVF   5B,W
02D0:  SUBWF  7A,F
02D1:  BSF    03.0
02D2:  RLF    78,F
02D3:  RLF    79,F
02D4:  DECFSZ 5C,F
02D5:  GOTO   2BE
*
03A0:  MOVLW  8E
03A1:  MOVWF  77
03A2:  MOVF   49,W
03A3:  MOVWF  78
03A4:  MOVF   48,W
03A5:  MOVWF  79
03A6:  CLRF   7A
03A7:  MOVF   78,F
03A8:  BTFSS  03.2
03A9:  GOTO   3B4
03AA:  MOVF   79,W
03AB:  MOVWF  78
03AC:  CLRF   79
03AD:  MOVLW  08
03AE:  SUBWF  77,F
03AF:  MOVF   78,F
03B0:  BTFSS  03.2
03B1:  GOTO   3B4
03B2:  CLRF   77
03B3:  GOTO   3BC
03B4:  BCF    03.0
03B5:  BTFSC  78.7
03B6:  GOTO   3BB
03B7:  RLF    79,F
03B8:  RLF    78,F
03B9:  DECF   77,F
03BA:  GOTO   3B4
03BB:  BCF    78.7
03BC:  RETURN
03BD:  MOVLW  80
03BE:  BTFSC  03.1
03BF:  XORWF  4D,F
03C0:  CLRF   52
03C1:  CLRF   53
03C2:  MOVF   49,W
03C3:  MOVWF  51
03C4:  MOVF   4D,W
03C5:  XORWF  51,F
03C6:  MOVF   48,W
03C7:  BTFSC  03.2
03C8:  GOTO   4AD
03C9:  MOVWF  50
03CA:  MOVWF  77
03CB:  MOVF   4C,W
03CC:  BTFSC  03.2
03CD:  GOTO   4B6
03CE:  SUBWF  50,F
03CF:  BTFSC  03.2
03D0:  GOTO   452
03D1:  BTFSS  03.0
03D2:  GOTO   410
03D3:  MOVF   4D,W
03D4:  MOVWF  56
03D5:  BSF    56.7
03D6:  MOVF   4E,W
03D7:  MOVWF  55
03D8:  MOVF   4F,W
03D9:  MOVWF  54
03DA:  CLRF   53
03DB:  BCF    03.0
03DC:  RRF    56,F
03DD:  RRF    55,F
03DE:  RRF    54,F
03DF:  RRF    53,F
03E0:  DECFSZ 50,F
03E1:  GOTO   3DA
03E2:  BTFSS  51.7
03E3:  GOTO   3E7
03E4:  BSF    52.0
03E5:  GOTO   4CA
03E6:  BCF    52.0
03E7:  BCF    50.0
03E8:  BSF    52.4
03E9:  MOVLW  4B
03EA:  MOVWF  04
03EB:  BCF    03.7
03EC:  GOTO   4DF
03ED:  BCF    52.4
03EE:  BTFSC  51.7
03EF:  GOTO   3FA
03F0:  BTFSS  50.0
03F1:  GOTO   405
03F2:  RRF    56,F
03F3:  RRF    55,F
03F4:  RRF    54,F
03F5:  RRF    53,F
03F6:  INCF   77,F
03F7:  BTFSC  03.2
03F8:  GOTO   4C5
03F9:  GOTO   405
03FA:  BTFSC  56.7
03FB:  GOTO   408
03FC:  BCF    03.0
03FD:  RLF    53,F
03FE:  RLF    54,F
03FF:  RLF    55,F
0400:  RLF    56,F
0401:  DECF   77,F
0402:  BTFSC  03.2
0403:  GOTO   4C5
0404:  GOTO   3FA
0405:  BSF    52.6
0406:  GOTO   472
0407:  BCF    52.6
0408:  MOVF   49,W
0409:  MOVWF  51
040A:  BTFSS  51.7
040B:  GOTO   40E
040C:  BSF    56.7
040D:  GOTO   4BE
040E:  BCF    56.7
040F:  GOTO   4BE
0410:  MOVF   4C,W
0411:  MOVWF  50
0412:  MOVWF  77
0413:  MOVF   48,W
0414:  SUBWF  50,F
0415:  MOVF   49,W
0416:  MOVWF  56
0417:  BSF    56.7
0418:  MOVF   4A,W
0419:  MOVWF  55
041A:  MOVF   4B,W
041B:  MOVWF  54
041C:  CLRF   53
041D:  BCF    03.0
041E:  RRF    56,F
041F:  RRF    55,F
0420:  RRF    54,F
0421:  RRF    53,F
0422:  DECFSZ 50,F
0423:  GOTO   41C
0424:  BTFSS  51.7
0425:  GOTO   429
0426:  BSF    52.1
0427:  GOTO   4CA
0428:  BCF    52.1
0429:  BCF    50.0
042A:  BSF    52.5
042B:  MOVLW  4F
042C:  MOVWF  04
042D:  BCF    03.7
042E:  GOTO   4DF
042F:  BCF    52.5
0430:  BTFSC  51.7
0431:  GOTO   43C
0432:  BTFSS  50.0
0433:  GOTO   447
0434:  RRF    56,F
0435:  RRF    55,F
0436:  RRF    54,F
0437:  RRF    53,F
0438:  INCF   77,F
0439:  BTFSC  03.2
043A:  GOTO   4C5
043B:  GOTO   447
043C:  BTFSC  56.7
043D:  GOTO   44A
043E:  BCF    03.0
043F:  RLF    53,F
0440:  RLF    54,F
0441:  RLF    55,F
0442:  RLF    56,F
0443:  DECF   77,F
0444:  BTFSC  03.2
0445:  GOTO   4C5
0446:  GOTO   43C
0447:  BSF    52.7
0448:  GOTO   472
0449:  BCF    52.7
044A:  MOVF   4D,W
044B:  MOVWF  51
044C:  BTFSS  51.7
044D:  GOTO   450
044E:  BSF    56.7
044F:  GOTO   4BE
0450:  BCF    56.7
0451:  GOTO   4BE
0452:  MOVF   4D,W
0453:  MOVWF  56
0454:  BSF    56.7
0455:  MOVF   4E,W
0456:  MOVWF  55
0457:  MOVF   4F,W
0458:  MOVWF  54
0459:  BTFSS  51.7
045A:  GOTO   45F
045B:  BCF    56.7
045C:  BSF    52.2
045D:  GOTO   4CA
045E:  BCF    52.2
045F:  CLRF   53
0460:  BCF    50.0
0461:  MOVLW  4B
0462:  MOVWF  04
0463:  BCF    03.7
0464:  GOTO   4DF
0465:  BTFSC  51.7
0466:  GOTO   488
0467:  MOVF   49,W
0468:  MOVWF  51
0469:  BTFSS  50.0
046A:  GOTO   472
046B:  RRF    56,F
046C:  RRF    55,F
046D:  RRF    54,F
046E:  RRF    53,F
046F:  INCF   77,F
0470:  BTFSC  03.2
0471:  GOTO   4C5
0472:  BTFSS  53.7
0473:  GOTO   483
0474:  INCF   54,F
0475:  BTFSS  03.2
0476:  GOTO   483
0477:  INCF   55,F
0478:  BTFSS  03.2
0479:  GOTO   483
047A:  INCF   56,F
047B:  BTFSS  03.2
047C:  GOTO   483
047D:  RRF    56,F
047E:  RRF    55,F
047F:  RRF    54,F
0480:  INCF   77,F
0481:  BTFSC  03.2
0482:  GOTO   4C5
0483:  BTFSC  52.6
0484:  GOTO   407
0485:  BTFSC  52.7
0486:  GOTO   449
0487:  GOTO   4A7
0488:  MOVLW  80
0489:  XORWF  56,F
048A:  BTFSS  56.7
048B:  GOTO   490
048C:  GOTO   4CA
048D:  MOVF   4D,W
048E:  MOVWF  51
048F:  GOTO   49D
0490:  MOVF   49,W
0491:  MOVWF  51
0492:  MOVF   56,F
0493:  BTFSS  03.2
0494:  GOTO   49D
0495:  MOVF   55,F
0496:  BTFSS  03.2
0497:  GOTO   49D
0498:  MOVF   54,F
0499:  BTFSS  03.2
049A:  GOTO   49D
049B:  CLRF   77
049C:  GOTO   4BE
049D:  BTFSC  56.7
049E:  GOTO   4A7
049F:  BCF    03.0
04A0:  RLF    53,F
04A1:  RLF    54,F
04A2:  RLF    55,F
04A3:  RLF    56,F
04A4:  DECFSZ 77,F
04A5:  GOTO   49D
04A6:  GOTO   4C5
04A7:  BTFSS  51.7
04A8:  GOTO   4AB
04A9:  BSF    56.7
04AA:  GOTO   4BE
04AB:  BCF    56.7
04AC:  GOTO   4BE
04AD:  MOVF   4C,W
04AE:  MOVWF  77
04AF:  MOVF   4D,W
04B0:  MOVWF  56
04B1:  MOVF   4E,W
04B2:  MOVWF  55
04B3:  MOVF   4F,W
04B4:  MOVWF  54
04B5:  GOTO   4BE
04B6:  MOVF   48,W
04B7:  MOVWF  77
04B8:  MOVF   49,W
04B9:  MOVWF  56
04BA:  MOVF   4A,W
04BB:  MOVWF  55
04BC:  MOVF   4B,W
04BD:  MOVWF  54
04BE:  MOVF   56,W
04BF:  MOVWF  78
04C0:  MOVF   55,W
04C1:  MOVWF  79
04C2:  MOVF   54,W
04C3:  MOVWF  7A
04C4:  GOTO   4FD
04C5:  CLRF   77
04C6:  CLRF   78
04C7:  CLRF   79
04C8:  CLRF   7A
04C9:  GOTO   4FD
04CA:  CLRF   53
04CB:  COMF   54,F
04CC:  COMF   55,F
04CD:  COMF   56,F
04CE:  COMF   53,F
04CF:  INCF   53,F
04D0:  BTFSS  03.2
04D1:  GOTO   4D8
04D2:  INCF   54,F
04D3:  BTFSS  03.2
04D4:  GOTO   4D8
04D5:  INCF   55,F
04D6:  BTFSC  03.2
04D7:  INCF   56,F
04D8:  BTFSC  52.0
04D9:  GOTO   3E6
04DA:  BTFSC  52.1
04DB:  GOTO   428
04DC:  BTFSC  52.2
04DD:  GOTO   45E
04DE:  GOTO   48D
04DF:  MOVF   00,W
04E0:  ADDWF  54,F
04E1:  BTFSS  03.0
04E2:  GOTO   4E9
04E3:  INCF   55,F
04E4:  BTFSS  03.2
04E5:  GOTO   4E9
04E6:  INCF   56,F
04E7:  BTFSC  03.2
04E8:  BSF    50.0
04E9:  DECF   04,F
04EA:  MOVF   00,W
04EB:  ADDWF  55,F
04EC:  BTFSS  03.0
04ED:  GOTO   4F1
04EE:  INCF   56,F
04EF:  BTFSC  03.2
04F0:  BSF    50.0
04F1:  DECF   04,F
04F2:  MOVF   00,W
04F3:  BTFSS  00.7
04F4:  XORLW  80
04F5:  ADDWF  56,F
04F6:  BTFSC  03.0
04F7:  BSF    50.0
04F8:  BTFSC  52.4
04F9:  GOTO   3ED
04FA:  BTFSC  52.5
04FB:  GOTO   42F
04FC:  GOTO   465
04FD:  RETURN
04FE:  MOVLW  8E
04FF:  MOVWF  77
0500:  MOVF   44,W
0501:  SUBWF  77,F
0502:  MOVF   45,W
0503:  MOVWF  79
0504:  MOVF   46,W
0505:  MOVWF  78
0506:  BSF    79.7
0507:  MOVF   77,F
0508:  BTFSC  03.2
0509:  GOTO   515
050A:  BCF    03.0
050B:  MOVF   79,F
050C:  BTFSS  03.2
050D:  GOTO   511
050E:  MOVF   78,F
050F:  BTFSC  03.2
0510:  GOTO   515
0511:  RRF    79,F
0512:  RRF    78,F
0513:  DECFSZ 77,F
0514:  GOTO   50A
0515:  BTFSS  45.7
0516:  GOTO   51C
0517:  COMF   78,F
0518:  COMF   79,F
0519:  INCF   78,F
051A:  BTFSC  03.2
051B:  INCF   79,F
051C:  RETURN
051D:  MOVF   48,W
051E:  BTFSC  03.2
051F:  GOTO   58D
0520:  MOVWF  50
0521:  MOVF   4C,W
0522:  BTFSC  03.2
0523:  GOTO   58D
0524:  ADDWF  50,F
0525:  BTFSC  03.0
0526:  GOTO   52E
0527:  MOVLW  7F
0528:  SUBWF  50,F
0529:  BTFSS  03.0
052A:  GOTO   58D
052B:  BTFSC  03.2
052C:  GOTO   58D
052D:  GOTO   532
052E:  MOVLW  81
052F:  ADDWF  50,F
0530:  BTFSC  03.0
0531:  GOTO   58D
0532:  MOVF   50,W
0533:  MOVWF  77
0534:  CLRF   78
0535:  CLRF   79
0536:  CLRF   7A
0537:  MOVF   49,W
0538:  MOVWF  54
0539:  BSF    54.7
053A:  MOVF   4A,W
053B:  MOVWF  53
053C:  MOVF   4B,W
053D:  MOVWF  52
053E:  MOVLW  18
053F:  MOVWF  50
0540:  CLRF   51
0541:  BTFSS  52.0
0542:  GOTO   55B
0543:  MOVF   4F,W
0544:  ADDWF  7A,F
0545:  BTFSS  03.0
0546:  GOTO   54D
0547:  INCF   79,F
0548:  BTFSS  03.2
0549:  GOTO   54D
054A:  INCF   78,F
054B:  BTFSC  03.2
054C:  BSF    51.7
054D:  MOVF   4E,W
054E:  ADDWF  79,F
054F:  BTFSS  03.0
0550:  GOTO   554
0551:  INCF   78,F
0552:  BTFSC  03.2
0553:  BSF    51.7
0554:  MOVF   4D,W
0555:  MOVWF  4A
0556:  BSF    4A.7
0557:  MOVF   4A,W
0558:  ADDWF  78,F
0559:  BTFSC  03.0
055A:  BSF    51.7
055B:  RLF    51,F
055C:  RRF    78,F
055D:  RRF    79,F
055E:  RRF    7A,F
055F:  RRF    54,F
0560:  RRF    53,F
0561:  RRF    52,F
0562:  BCF    03.0
0563:  DECFSZ 50,F
0564:  GOTO   540
0565:  MOVLW  01
0566:  ADDWF  77,F
0567:  BTFSC  03.0
0568:  GOTO   58D
0569:  BTFSC  78.7
056A:  GOTO   572
056B:  RLF    54,F
056C:  RLF    7A,F
056D:  RLF    79,F
056E:  RLF    78,F
056F:  DECF   77,F
0570:  BTFSC  03.2
0571:  GOTO   58D
0572:  BTFSS  54.7
0573:  GOTO   583
0574:  INCF   7A,F
0575:  BTFSS  03.2
0576:  GOTO   583
0577:  INCF   79,F
0578:  BTFSS  03.2
0579:  GOTO   583
057A:  INCF   78,F
057B:  BTFSS  03.2
057C:  GOTO   583
057D:  RRF    78,F
057E:  RRF    79,F
057F:  RRF    7A,F
0580:  INCF   77,F
0581:  BTFSC  03.2
0582:  GOTO   58D
0583:  MOVF   49,W
0584:  MOVWF  51
0585:  MOVF   4D,W
0586:  XORWF  51,F
0587:  BTFSS  51.7
0588:  GOTO   58B
0589:  BSF    78.7
058A:  GOTO   591
058B:  BCF    78.7
058C:  GOTO   591
058D:  CLRF   77
058E:  CLRF   78
058F:  CLRF   79
0590:  CLRF   7A
0591:  RETURN
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(clock=20000000)
*
0037:  MOVLW  44
0038:  MOVWF  04
0039:  BCF    03.7
003A:  MOVF   00,W
003B:  BTFSC  03.2
003C:  GOTO   04A
003D:  MOVLW  06
003E:  MOVWF  78
003F:  CLRF   77
0040:  DECFSZ 77,F
0041:  GOTO   040
0042:  DECFSZ 78,F
0043:  GOTO   03F
0044:  MOVLW  7B
0045:  MOVWF  77
0046:  DECFSZ 77,F
0047:  GOTO   046
0048:  DECFSZ 00,F
0049:  GOTO   03D
004A:  RETURN
.................... #fuses HS, NOWDT, NOPROTECT, NOLVP
.................... #use rs232 (baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8)
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0677:  BCF    03.5
0678:  CLRF   20
0679:  CLRF   21
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... float e_env = 0, prev_e = 0;
.................... 
.................... int16 v_ref = 150;
.................... char P = 0, I = 0, D = 0;
.................... int8 PID_Val = 0;
.................... float Kp = 8;
.................... float Ki = 0;
.................... float Kd = 6;
.................... 
.................... int16 Calib (INT16 x)
.................... {
....................    if (x > 650) RETURN 650;
*
004B:  MOVF   57,W
004C:  SUBLW  01
004D:  BTFSC  03.0
004E:  GOTO   05C
004F:  XORLW  FF
0050:  BTFSS  03.2
0051:  GOTO   056
0052:  MOVF   56,W
0053:  SUBLW  8A
0054:  BTFSC  03.0
0055:  GOTO   05C
0056:  MOVLW  8A
0057:  MOVWF  78
0058:  MOVLW  02
0059:  MOVWF  79
005A:  GOTO   06D
005B:  GOTO   06D
....................    else if (x < 50) RETURN 50;
005C:  MOVF   57,F
005D:  BTFSS  03.2
005E:  GOTO   069
005F:  MOVF   56,W
0060:  SUBLW  31
0061:  BTFSS  03.0
0062:  GOTO   069
0063:  MOVLW  32
0064:  MOVWF  78
0065:  MOVLW  00
0066:  MOVWF  79
0067:  GOTO   06D
0068:  GOTO   06D
....................    else RETURN x;
0069:  MOVF   56,W
006A:  MOVWF  78
006B:  MOVF   57,W
006C:  MOVWF  79
006D:  RETURN
.................... }
.................... 
.................... int16 AVG_Index(boolean init) 
.................... {
....................    INT16 x0, x1, x2, x3, x4, x5, x6;
....................    INT16 e;
....................    set_adc_channel (0);
*
0135:  MOVLW  00
0136:  MOVWF  78
0137:  MOVF   1F,W
0138:  ANDLW  C7
0139:  IORWF  78,W
013A:  MOVWF  1F
....................    delay_us (10);
013B:  MOVLW  10
013C:  MOVWF  77
013D:  DECFSZ 77,F
013E:  GOTO   13D
013F:  NOP
....................    x0 = Calib (read_adc ());
0140:  BSF    1F.2
0141:  BTFSC  1F.2
0142:  GOTO   141
0143:  MOVF   1E,W
0144:  MOVWF  79
0145:  BSF    03.5
0146:  MOVF   1E,W
0147:  MOVWF  78
0148:  MOVF   79,W
0149:  BCF    03.5
014A:  MOVWF  55
014B:  MOVF   78,W
014C:  MOVWF  54
014D:  MOVF   55,W
014E:  MOVWF  57
014F:  MOVF   78,W
0150:  MOVWF  56
0151:  CALL   04B
0152:  MOVF   79,W
0153:  MOVWF  45
0154:  MOVF   78,W
0155:  MOVWF  44
....................    
....................    set_adc_channel (1);
0156:  MOVLW  08
0157:  MOVWF  78
0158:  MOVF   1F,W
0159:  ANDLW  C7
015A:  IORWF  78,W
015B:  MOVWF  1F
....................    delay_us (10);
015C:  MOVLW  10
015D:  MOVWF  77
015E:  DECFSZ 77,F
015F:  GOTO   15E
0160:  NOP
....................    x1 = Calib (read_adc ());
0161:  BSF    1F.2
0162:  BTFSC  1F.2
0163:  GOTO   162
0164:  MOVF   1E,W
0165:  MOVWF  79
0166:  BSF    03.5
0167:  MOVF   1E,W
0168:  MOVWF  78
0169:  MOVF   79,W
016A:  BCF    03.5
016B:  MOVWF  55
016C:  MOVF   78,W
016D:  MOVWF  54
016E:  MOVF   55,W
016F:  MOVWF  57
0170:  MOVF   78,W
0171:  MOVWF  56
0172:  CALL   04B
0173:  MOVF   79,W
0174:  MOVWF  47
0175:  MOVF   78,W
0176:  MOVWF  46
....................    
....................    set_adc_channel (2);
0177:  MOVLW  10
0178:  MOVWF  78
0179:  MOVF   1F,W
017A:  ANDLW  C7
017B:  IORWF  78,W
017C:  MOVWF  1F
....................    delay_us (10);
017D:  MOVLW  10
017E:  MOVWF  77
017F:  DECFSZ 77,F
0180:  GOTO   17F
0181:  NOP
....................    x2 = Calib (read_adc ());
0182:  BSF    1F.2
0183:  BTFSC  1F.2
0184:  GOTO   183
0185:  MOVF   1E,W
0186:  MOVWF  79
0187:  BSF    03.5
0188:  MOVF   1E,W
0189:  MOVWF  78
018A:  MOVF   79,W
018B:  BCF    03.5
018C:  MOVWF  55
018D:  MOVF   78,W
018E:  MOVWF  54
018F:  MOVF   55,W
0190:  MOVWF  57
0191:  MOVF   78,W
0192:  MOVWF  56
0193:  CALL   04B
0194:  MOVF   79,W
0195:  MOVWF  49
0196:  MOVF   78,W
0197:  MOVWF  48
....................    
....................    set_adc_channel (3);
0198:  MOVLW  18
0199:  MOVWF  78
019A:  MOVF   1F,W
019B:  ANDLW  C7
019C:  IORWF  78,W
019D:  MOVWF  1F
....................    delay_us (10);
019E:  MOVLW  10
019F:  MOVWF  77
01A0:  DECFSZ 77,F
01A1:  GOTO   1A0
01A2:  NOP
....................    x3 = Calib (read_adc ());
01A3:  BSF    1F.2
01A4:  BTFSC  1F.2
01A5:  GOTO   1A4
01A6:  MOVF   1E,W
01A7:  MOVWF  79
01A8:  BSF    03.5
01A9:  MOVF   1E,W
01AA:  MOVWF  78
01AB:  MOVF   79,W
01AC:  BCF    03.5
01AD:  MOVWF  55
01AE:  MOVF   78,W
01AF:  MOVWF  54
01B0:  MOVF   55,W
01B1:  MOVWF  57
01B2:  MOVF   78,W
01B3:  MOVWF  56
01B4:  CALL   04B
01B5:  MOVF   79,W
01B6:  MOVWF  4B
01B7:  MOVF   78,W
01B8:  MOVWF  4A
....................    
....................    set_adc_channel (4);
01B9:  MOVLW  20
01BA:  MOVWF  78
01BB:  MOVF   1F,W
01BC:  ANDLW  C7
01BD:  IORWF  78,W
01BE:  MOVWF  1F
....................    delay_us (10);
01BF:  MOVLW  10
01C0:  MOVWF  77
01C1:  DECFSZ 77,F
01C2:  GOTO   1C1
01C3:  NOP
....................    x4 = Calib (read_adc ());
01C4:  BSF    1F.2
01C5:  BTFSC  1F.2
01C6:  GOTO   1C5
01C7:  MOVF   1E,W
01C8:  MOVWF  79
01C9:  BSF    03.5
01CA:  MOVF   1E,W
01CB:  MOVWF  78
01CC:  MOVF   79,W
01CD:  BCF    03.5
01CE:  MOVWF  55
01CF:  MOVF   78,W
01D0:  MOVWF  54
01D1:  MOVF   55,W
01D2:  MOVWF  57
01D3:  MOVF   78,W
01D4:  MOVWF  56
01D5:  CALL   04B
01D6:  MOVF   79,W
01D7:  MOVWF  4D
01D8:  MOVF   78,W
01D9:  MOVWF  4C
....................    
....................    set_adc_channel (5);
01DA:  MOVLW  28
01DB:  MOVWF  78
01DC:  MOVF   1F,W
01DD:  ANDLW  C7
01DE:  IORWF  78,W
01DF:  MOVWF  1F
....................    delay_us (10);
01E0:  MOVLW  10
01E1:  MOVWF  77
01E2:  DECFSZ 77,F
01E3:  GOTO   1E2
01E4:  NOP
....................    x5 = Calib (read_adc ());
01E5:  BSF    1F.2
01E6:  BTFSC  1F.2
01E7:  GOTO   1E6
01E8:  MOVF   1E,W
01E9:  MOVWF  79
01EA:  BSF    03.5
01EB:  MOVF   1E,W
01EC:  MOVWF  78
01ED:  MOVF   79,W
01EE:  BCF    03.5
01EF:  MOVWF  55
01F0:  MOVF   78,W
01F1:  MOVWF  54
01F2:  MOVF   55,W
01F3:  MOVWF  57
01F4:  MOVF   78,W
01F5:  MOVWF  56
01F6:  CALL   04B
01F7:  MOVF   79,W
01F8:  MOVWF  4F
01F9:  MOVF   78,W
01FA:  MOVWF  4E
....................    
....................    set_adc_channel (6);
01FB:  MOVLW  30
01FC:  MOVWF  78
01FD:  MOVF   1F,W
01FE:  ANDLW  C7
01FF:  IORWF  78,W
0200:  MOVWF  1F
....................    delay_us (10);
0201:  MOVLW  10
0202:  MOVWF  77
0203:  DECFSZ 77,F
0204:  GOTO   203
0205:  NOP
....................    x6 = Calib (read_adc ());
0206:  BSF    1F.2
0207:  BTFSC  1F.2
0208:  GOTO   207
0209:  MOVF   1E,W
020A:  MOVWF  79
020B:  BSF    03.5
020C:  MOVF   1E,W
020D:  MOVWF  78
020E:  MOVF   79,W
020F:  BCF    03.5
0210:  MOVWF  55
0211:  MOVF   78,W
0212:  MOVWF  54
0213:  MOVF   55,W
0214:  MOVWF  57
0215:  MOVF   78,W
0216:  MOVWF  56
0217:  CALL   04B
0218:  MOVF   79,W
0219:  MOVWF  51
021A:  MOVF   78,W
021B:  MOVWF  50
....................    
....................    e = 17 * (( - 3) * x0 + ( - 2) * x1 + (-1) * x2 + 0 * x3 + 1 * x4 + 2 * x5 + 3 * x6) / (x0 + x1 + x2 + x3 + x4 + x5 + x6) ;
021C:  MOVLW  FF
021D:  MOVWF  57
021E:  MOVLW  FD
021F:  MOVWF  56
0220:  MOVF   45,W
0221:  MOVWF  59
0222:  MOVF   44,W
0223:  MOVWF  58
0224:  CALL   06E
0225:  MOVF   79,W
0226:  MOVWF  55
0227:  MOVF   78,W
0228:  MOVWF  54
0229:  MOVLW  FF
022A:  MOVWF  57
022B:  MOVLW  FE
022C:  MOVWF  56
022D:  MOVF   47,W
022E:  MOVWF  59
022F:  MOVF   46,W
0230:  MOVWF  58
0231:  CALL   06E
0232:  MOVF   79,W
0233:  MOVWF  7A
0234:  MOVF   78,W
0235:  ADDWF  54,F
0236:  MOVF   7A,W
0237:  BTFSC  03.0
0238:  INCFSZ 7A,W
0239:  ADDWF  55,F
023A:  MOVLW  FF
023B:  MOVWF  57
023C:  MOVWF  56
023D:  MOVF   49,W
023E:  MOVWF  59
023F:  MOVF   48,W
0240:  MOVWF  58
0241:  CALL   06E
0242:  MOVF   79,W
0243:  MOVWF  7A
0244:  MOVF   78,W
0245:  ADDWF  54,F
0246:  MOVF   7A,W
0247:  BTFSC  03.0
0248:  INCFSZ 7A,W
0249:  ADDWF  55,F
024A:  MOVF   4C,W
024B:  ADDWF  54,F
024C:  MOVF   4D,W
024D:  BTFSC  03.0
024E:  INCFSZ 4D,W
024F:  ADDWF  55,F
0250:  BCF    03.0
0251:  RLF    4E,W
0252:  MOVWF  79
0253:  RLF    4F,W
0254:  MOVWF  7A
0255:  MOVF   79,W
0256:  ADDWF  54,F
0257:  MOVF   7A,W
0258:  BTFSC  03.0
0259:  INCFSZ 7A,W
025A:  ADDWF  55,F
025B:  CLRF   57
025C:  MOVLW  03
025D:  MOVWF  56
025E:  MOVF   51,W
025F:  MOVWF  59
0260:  MOVF   50,W
0261:  MOVWF  58
0262:  CALL   06E
0263:  MOVF   79,W
0264:  MOVWF  7A
0265:  MOVF   78,W
0266:  ADDWF  54,W
0267:  MOVWF  78
0268:  MOVF   55,W
0269:  BTFSC  03.0
026A:  INCFSZ 55,W
026B:  ADDWF  7A,F
026C:  MOVF   78,W
026D:  MOVWF  54
026E:  MOVF   7A,W
026F:  MOVWF  55
0270:  CLRF   57
0271:  MOVLW  11
0272:  MOVWF  56
0273:  MOVF   55,W
0274:  MOVWF  59
0275:  MOVF   54,W
0276:  MOVWF  58
0277:  CALL   06E
0278:  MOVF   79,W
0279:  MOVWF  55
027A:  MOVF   78,W
027B:  MOVWF  54
027C:  MOVF   46,W
027D:  ADDWF  44,W
027E:  MOVWF  56
027F:  MOVF   45,W
0280:  MOVWF  57
0281:  MOVF   47,W
0282:  BTFSC  03.0
0283:  INCFSZ 47,W
0284:  ADDWF  57,F
0285:  MOVF   48,W
0286:  ADDWF  56,F
0287:  MOVF   49,W
0288:  BTFSC  03.0
0289:  INCFSZ 49,W
028A:  ADDWF  57,F
028B:  MOVF   4A,W
028C:  ADDWF  56,F
028D:  MOVF   4B,W
028E:  BTFSC  03.0
028F:  INCFSZ 4B,W
0290:  ADDWF  57,F
0291:  MOVF   4C,W
0292:  ADDWF  56,F
0293:  MOVF   4D,W
0294:  BTFSC  03.0
0295:  INCFSZ 4D,W
0296:  ADDWF  57,F
0297:  MOVF   4E,W
0298:  ADDWF  56,F
0299:  MOVF   4F,W
029A:  BTFSC  03.0
029B:  INCFSZ 4F,W
029C:  ADDWF  57,F
029D:  MOVF   50,W
029E:  ADDWF  56,W
029F:  MOVWF  78
02A0:  MOVF   57,W
02A1:  MOVWF  7A
02A2:  MOVF   51,W
02A3:  BTFSC  03.0
02A4:  INCFSZ 51,W
02A5:  ADDWF  7A,F
02A6:  MOVF   78,W
02A7:  MOVWF  56
02A8:  MOVF   7A,W
02A9:  MOVWF  57
02AA:  MOVF   55,W
02AB:  MOVWF  59
02AC:  MOVF   54,W
02AD:  MOVWF  58
02AE:  MOVF   57,W
02AF:  MOVWF  5B
02B0:  MOVF   56,W
02B1:  MOVWF  5A
*
02D6:  MOVF   79,W
02D7:  MOVWF  53
02D8:  MOVF   78,W
02D9:  MOVWF  52
....................    
....................    IF (init) printf ("e_env = %lu\t", e);
02DA:  MOVF   43,F
02DB:  BTFSC  03.2
02DC:  GOTO   2F3
02DD:  MOVLW  04
02DE:  BSF    03.6
02DF:  MOVWF  0D
02E0:  MOVLW  00
02E1:  MOVWF  0F
02E2:  BCF    03.0
02E3:  MOVLW  08
02E4:  BCF    03.6
02E5:  MOVWF  54
02E6:  CALL   083
02E7:  MOVLW  10
02E8:  MOVWF  04
02E9:  MOVF   53,W
02EA:  MOVWF  55
02EB:  MOVF   52,W
02EC:  MOVWF  54
02ED:  CALL   0DC
02EE:  MOVLW  09
02EF:  BTFSS  0C.4
02F0:  GOTO   2EF
02F1:  MOVWF  19
02F2:  GOTO   39B
.................... 
....................    ELSE
....................    {
....................       printf ("CB1 = %lu", x0);
02F3:  MOVLW  0B
02F4:  BSF    03.6
02F5:  MOVWF  0D
02F6:  MOVLW  00
02F7:  MOVWF  0F
02F8:  BCF    03.0
02F9:  MOVLW  06
02FA:  BCF    03.6
02FB:  MOVWF  54
02FC:  CALL   083
02FD:  MOVLW  10
02FE:  MOVWF  04
02FF:  MOVF   45,W
0300:  MOVWF  55
0301:  MOVF   44,W
0302:  MOVWF  54
0303:  CALL   0DC
....................       printf ("\t");
0304:  MOVLW  09
0305:  BTFSS  0C.4
0306:  GOTO   305
0307:  MOVWF  19
....................       printf ("CB2 = %lu", x1);
0308:  MOVLW  10
0309:  BSF    03.6
030A:  MOVWF  0D
030B:  MOVLW  00
030C:  MOVWF  0F
030D:  BCF    03.0
030E:  MOVLW  06
030F:  BCF    03.6
0310:  MOVWF  54
0311:  CALL   083
0312:  MOVLW  10
0313:  MOVWF  04
0314:  MOVF   47,W
0315:  MOVWF  55
0316:  MOVF   46,W
0317:  MOVWF  54
0318:  CALL   0DC
....................       printf ("\t");
0319:  MOVLW  09
031A:  BTFSS  0C.4
031B:  GOTO   31A
031C:  MOVWF  19
....................       printf ("CB3 = %lu", x2);
031D:  MOVLW  15
031E:  BSF    03.6
031F:  MOVWF  0D
0320:  MOVLW  00
0321:  MOVWF  0F
0322:  BCF    03.0
0323:  MOVLW  06
0324:  BCF    03.6
0325:  MOVWF  54
0326:  CALL   083
0327:  MOVLW  10
0328:  MOVWF  04
0329:  MOVF   49,W
032A:  MOVWF  55
032B:  MOVF   48,W
032C:  MOVWF  54
032D:  CALL   0DC
....................       printf ("\t");
032E:  MOVLW  09
032F:  BTFSS  0C.4
0330:  GOTO   32F
0331:  MOVWF  19
....................       printf ("CB4 = %lu", x3);
0332:  MOVLW  1A
0333:  BSF    03.6
0334:  MOVWF  0D
0335:  MOVLW  00
0336:  MOVWF  0F
0337:  BCF    03.0
0338:  MOVLW  06
0339:  BCF    03.6
033A:  MOVWF  54
033B:  CALL   083
033C:  MOVLW  10
033D:  MOVWF  04
033E:  MOVF   4B,W
033F:  MOVWF  55
0340:  MOVF   4A,W
0341:  MOVWF  54
0342:  CALL   0DC
....................       printf ("\t");
0343:  MOVLW  09
0344:  BTFSS  0C.4
0345:  GOTO   344
0346:  MOVWF  19
....................       printf ("CB5 = %lu", x4);
0347:  MOVLW  1F
0348:  BSF    03.6
0349:  MOVWF  0D
034A:  MOVLW  00
034B:  MOVWF  0F
034C:  BCF    03.0
034D:  MOVLW  06
034E:  BCF    03.6
034F:  MOVWF  54
0350:  CALL   083
0351:  MOVLW  10
0352:  MOVWF  04
0353:  MOVF   4D,W
0354:  MOVWF  55
0355:  MOVF   4C,W
0356:  MOVWF  54
0357:  CALL   0DC
....................       printf ("\t");
0358:  MOVLW  09
0359:  BTFSS  0C.4
035A:  GOTO   359
035B:  MOVWF  19
....................       printf ("CB6 = %lu", x5);
035C:  MOVLW  24
035D:  BSF    03.6
035E:  MOVWF  0D
035F:  MOVLW  00
0360:  MOVWF  0F
0361:  BCF    03.0
0362:  MOVLW  06
0363:  BCF    03.6
0364:  MOVWF  54
0365:  CALL   083
0366:  MOVLW  10
0367:  MOVWF  04
0368:  MOVF   4F,W
0369:  MOVWF  55
036A:  MOVF   4E,W
036B:  MOVWF  54
036C:  CALL   0DC
....................       printf ("\t");
036D:  MOVLW  09
036E:  BTFSS  0C.4
036F:  GOTO   36E
0370:  MOVWF  19
....................       printf ("CB7 = %lu", x6);
0371:  MOVLW  29
0372:  BSF    03.6
0373:  MOVWF  0D
0374:  MOVLW  00
0375:  MOVWF  0F
0376:  BCF    03.0
0377:  MOVLW  06
0378:  BCF    03.6
0379:  MOVWF  54
037A:  CALL   083
037B:  MOVLW  10
037C:  MOVWF  04
037D:  MOVF   51,W
037E:  MOVWF  55
037F:  MOVF   50,W
0380:  MOVWF  54
0381:  CALL   0DC
....................       printf ("\t");
0382:  MOVLW  09
0383:  BTFSS  0C.4
0384:  GOTO   383
0385:  MOVWF  19
....................       printf ("Khoang cach = %lu", e);
0386:  MOVLW  2E
0387:  BSF    03.6
0388:  MOVWF  0D
0389:  MOVLW  00
038A:  MOVWF  0F
038B:  BCF    03.0
038C:  MOVLW  0E
038D:  BCF    03.6
038E:  MOVWF  54
038F:  CALL   083
0390:  MOVLW  10
0391:  MOVWF  04
0392:  MOVF   53,W
0393:  MOVWF  55
0394:  MOVF   52,W
0395:  MOVWF  54
0396:  CALL   0DC
....................       printf ("\t");
0397:  MOVLW  09
0398:  BTFSS  0C.4
0399:  GOTO   398
039A:  MOVWF  19
....................    }
.................... 
....................    
....................    RETURN e;
039B:  MOVF   52,W
039C:  MOVWF  78
039D:  MOVF   53,W
039E:  MOVWF  79
039F:  RETURN
.................... }
.................... 
.................... void PID (INT e) 
.................... {
....................    P = e;
*
0592:  MOVF   43,W
0593:  MOVWF  30
....................    I = I + e;
0594:  MOVF   43,W
0595:  ADDWF  31,F
....................    D = e - prev_e;
0596:  CLRF   49
0597:  MOVF   43,W
0598:  MOVWF  48
0599:  CALL   3A0
059A:  BSF    03.1
059B:  MOVF   7A,W
059C:  MOVWF  4B
059D:  MOVF   79,W
059E:  MOVWF  4A
059F:  MOVF   78,W
05A0:  MOVWF  49
05A1:  MOVF   77,W
05A2:  MOVWF  48
05A3:  MOVF   2D,W
05A4:  MOVWF  4F
05A5:  MOVF   2C,W
05A6:  MOVWF  4E
05A7:  MOVF   2B,W
05A8:  MOVWF  4D
05A9:  MOVF   2A,W
05AA:  MOVWF  4C
05AB:  CALL   3BD
05AC:  MOVF   7A,W
05AD:  MOVWF  47
05AE:  MOVF   79,W
05AF:  MOVWF  46
05B0:  MOVF   78,W
05B1:  MOVWF  45
05B2:  MOVF   77,W
05B3:  MOVWF  44
05B4:  CALL   4FE
05B5:  MOVF   78,W
05B6:  MOVWF  32
....................    PID_Val = Kp * P + Ki * I + Kd*D;
05B7:  CLRF   49
05B8:  MOVF   30,W
05B9:  MOVWF  48
05BA:  CALL   3A0
05BB:  MOVF   37,W
05BC:  MOVWF  4B
05BD:  MOVF   36,W
05BE:  MOVWF  4A
05BF:  MOVF   35,W
05C0:  MOVWF  49
05C1:  MOVF   34,W
05C2:  MOVWF  48
05C3:  MOVF   7A,W
05C4:  MOVWF  4F
05C5:  MOVF   79,W
05C6:  MOVWF  4E
05C7:  MOVF   78,W
05C8:  MOVWF  4D
05C9:  MOVF   77,W
05CA:  MOVWF  4C
05CB:  CALL   51D
05CC:  MOVF   7A,W
05CD:  MOVWF  47
05CE:  MOVF   79,W
05CF:  MOVWF  46
05D0:  MOVF   78,W
05D1:  MOVWF  45
05D2:  MOVF   77,W
05D3:  MOVWF  44
05D4:  CLRF   49
05D5:  MOVF   31,W
05D6:  MOVWF  48
05D7:  CALL   3A0
05D8:  MOVF   3B,W
05D9:  MOVWF  4B
05DA:  MOVF   3A,W
05DB:  MOVWF  4A
05DC:  MOVF   39,W
05DD:  MOVWF  49
05DE:  MOVF   38,W
05DF:  MOVWF  48
05E0:  MOVF   7A,W
05E1:  MOVWF  4F
05E2:  MOVF   79,W
05E3:  MOVWF  4E
05E4:  MOVF   78,W
05E5:  MOVWF  4D
05E6:  MOVF   77,W
05E7:  MOVWF  4C
05E8:  CALL   51D
05E9:  BCF    03.1
05EA:  MOVF   47,W
05EB:  MOVWF  4B
05EC:  MOVF   46,W
05ED:  MOVWF  4A
05EE:  MOVF   45,W
05EF:  MOVWF  49
05F0:  MOVF   44,W
05F1:  MOVWF  48
05F2:  MOVF   7A,W
05F3:  MOVWF  4F
05F4:  MOVF   79,W
05F5:  MOVWF  4E
05F6:  MOVF   78,W
05F7:  MOVWF  4D
05F8:  MOVF   77,W
05F9:  MOVWF  4C
05FA:  CALL   3BD
05FB:  MOVF   7A,W
05FC:  MOVWF  47
05FD:  MOVF   79,W
05FE:  MOVWF  46
05FF:  MOVF   78,W
0600:  MOVWF  45
0601:  MOVF   77,W
0602:  MOVWF  44
0603:  CLRF   49
0604:  MOVF   32,W
0605:  MOVWF  48
0606:  CALL   3A0
0607:  MOVF   3F,W
0608:  MOVWF  4B
0609:  MOVF   3E,W
060A:  MOVWF  4A
060B:  MOVF   3D,W
060C:  MOVWF  49
060D:  MOVF   3C,W
060E:  MOVWF  48
060F:  MOVF   7A,W
0610:  MOVWF  4F
0611:  MOVF   79,W
0612:  MOVWF  4E
0613:  MOVF   78,W
0614:  MOVWF  4D
0615:  MOVF   77,W
0616:  MOVWF  4C
0617:  CALL   51D
0618:  BCF    03.1
0619:  MOVF   47,W
061A:  MOVWF  4B
061B:  MOVF   46,W
061C:  MOVWF  4A
061D:  MOVF   45,W
061E:  MOVWF  49
061F:  MOVF   44,W
0620:  MOVWF  48
0621:  MOVF   7A,W
0622:  MOVWF  4F
0623:  MOVF   79,W
0624:  MOVWF  4E
0625:  MOVF   78,W
0626:  MOVWF  4D
0627:  MOVF   77,W
0628:  MOVWF  4C
0629:  CALL   3BD
062A:  MOVF   7A,W
062B:  MOVWF  47
062C:  MOVF   79,W
062D:  MOVWF  46
062E:  MOVF   78,W
062F:  MOVWF  45
0630:  MOVF   77,W
0631:  MOVWF  44
0632:  CALL   4FE
0633:  MOVF   78,W
0634:  MOVWF  33
....................    prev_e = e;
0635:  CLRF   49
0636:  MOVF   43,W
0637:  MOVWF  48
0638:  CALL   3A0
0639:  MOVF   7A,W
063A:  MOVWF  2D
063B:  MOVF   79,W
063C:  MOVWF  2C
063D:  MOVF   78,W
063E:  MOVWF  2B
063F:  MOVF   77,W
0640:  MOVWF  2A
0641:  BCF    0A.3
0642:  BCF    0A.4
0643:  GOTO   70A (RETURN)
.................... }
.................... 
.................... void main()
0644:  MOVF   03,W
0645:  ANDLW  1F
0646:  MOVWF  03
0647:  MOVLW  81
0648:  BSF    03.5
0649:  MOVWF  19
064A:  MOVLW  A6
064B:  MOVWF  18
064C:  MOVLW  90
064D:  BCF    03.5
064E:  MOVWF  18
064F:  CLRF   29
0650:  CLRF   28
0651:  CLRF   27
0652:  CLRF   26
0653:  CLRF   2D
0654:  CLRF   2C
0655:  CLRF   2B
0656:  CLRF   2A
0657:  CLRF   2F
0658:  MOVLW  96
0659:  MOVWF  2E
065A:  CLRF   30
065B:  CLRF   31
065C:  CLRF   32
065D:  CLRF   33
065E:  CLRF   37
065F:  CLRF   36
0660:  CLRF   35
0661:  MOVLW  82
0662:  MOVWF  34
0663:  CLRF   3B
0664:  CLRF   3A
0665:  CLRF   39
0666:  CLRF   38
0667:  CLRF   3F
0668:  CLRF   3E
0669:  MOVLW  40
066A:  MOVWF  3D
066B:  MOVLW  81
066C:  MOVWF  3C
066D:  MOVLW  FF
066E:  MOVWF  40
066F:  BSF    03.5
0670:  BSF    1F.0
0671:  BSF    1F.1
0672:  BSF    1F.2
0673:  BCF    1F.3
0674:  MOVLW  07
0675:  MOVWF  1C
0676:  BCF    03.7
.................... {
....................    setup_adc_ports (ALL_ANALOG);
*
067A:  BSF    03.5
067B:  BCF    1F.0
067C:  BCF    1F.1
067D:  BCF    1F.2
067E:  BCF    1F.3
....................    setup_adc (ADC_CLOCK_INTERNAL);
067F:  BCF    1F.6
0680:  BCF    03.5
0681:  BSF    1F.6
0682:  BSF    1F.7
0683:  BSF    03.5
0684:  BSF    1F.7
0685:  BCF    03.5
0686:  BSF    1F.0
....................    
....................    setup_ccp1 (CCP_PWM);
0687:  BCF    40.2
0688:  MOVF   40,W
0689:  BSF    03.5
068A:  MOVWF  07
068B:  BCF    03.5
068C:  BCF    07.2
068D:  MOVLW  0C
068E:  MOVWF  17
....................    setup_ccp2 (CCP_PWM);
068F:  BCF    40.1
0690:  MOVF   40,W
0691:  BSF    03.5
0692:  MOVWF  07
0693:  BCF    03.5
0694:  BCF    07.1
0695:  MOVLW  0C
0696:  MOVWF  1D
....................    setup_timer_2 (T2_DIV_BY_1, 249, 1) ;
0697:  MOVLW  00
0698:  MOVWF  78
0699:  IORLW  04
069A:  MOVWF  12
069B:  MOVLW  F9
069C:  BSF    03.5
069D:  MOVWF  12
....................    
....................    delay_ms (500);
069E:  MOVLW  02
069F:  BCF    03.5
06A0:  MOVWF  43
06A1:  MOVLW  FA
06A2:  MOVWF  44
06A3:  CALL   037
06A4:  DECFSZ 43,F
06A5:  GOTO   6A1
....................    output_high (PIN_D4);
06A6:  BSF    03.5
06A7:  BCF    08.4
06A8:  BCF    03.5
06A9:  BSF    08.4
....................    e_env = AVG_Index (TRUE);
06AA:  MOVLW  01
06AB:  MOVWF  43
06AC:  CALL   135
06AD:  MOVF   79,W
06AE:  MOVWF  49
06AF:  MOVF   78,W
06B0:  MOVWF  48
06B1:  CALL   3A0
06B2:  MOVF   7A,W
06B3:  MOVWF  29
06B4:  MOVF   79,W
06B5:  MOVWF  28
06B6:  MOVF   78,W
06B7:  MOVWF  27
06B8:  MOVF   77,W
06B9:  MOVWF  26
....................    delay_ms (1000);
06BA:  MOVLW  04
06BB:  MOVWF  43
06BC:  MOVLW  FA
06BD:  MOVWF  44
06BE:  CALL   037
06BF:  DECFSZ 43,F
06C0:  GOTO   6BC
....................    output_low (PIN_D4);
06C1:  BSF    03.5
06C2:  BCF    08.4
06C3:  BCF    03.5
06C4:  BCF    08.4
....................    output_high (PIN_D0);
06C5:  BSF    03.5
06C6:  BCF    08.0
06C7:  BCF    03.5
06C8:  BSF    08.0
....................    output_low (PIN_D1);
06C9:  BSF    03.5
06CA:  BCF    08.1
06CB:  BCF    03.5
06CC:  BCF    08.1
....................    
....................    output_high (PIN_D2);
06CD:  BSF    03.5
06CE:  BCF    08.2
06CF:  BCF    03.5
06D0:  BSF    08.2
....................    output_low (PIN_D3);
06D1:  BSF    03.5
06D2:  BCF    08.3
06D3:  BCF    03.5
06D4:  BCF    08.3
....................    set_pwm1_duty (v_ref);
06D5:  MOVF   2F,W
06D6:  MOVWF  79
06D7:  MOVF   2E,W
06D8:  MOVWF  78
06D9:  RRF    79,F
06DA:  RRF    78,F
06DB:  RRF    79,F
06DC:  RRF    78,F
06DD:  RRF    79,F
06DE:  MOVF   78,W
06DF:  MOVWF  15
06E0:  RRF    79,F
06E1:  RRF    79,W
06E2:  ANDLW  30
06E3:  MOVWF  77
06E4:  MOVF   17,W
06E5:  ANDLW  CF
06E6:  IORWF  77,W
06E7:  MOVWF  17
....................    set_pwm2_duty (v_ref);
06E8:  MOVF   2F,W
06E9:  MOVWF  79
06EA:  MOVF   2E,W
06EB:  MOVWF  78
06EC:  RRF    79,F
06ED:  RRF    78,F
06EE:  RRF    79,F
06EF:  RRF    78,F
06F0:  RRF    79,F
06F1:  MOVF   78,W
06F2:  MOVWF  1B
06F3:  RRF    79,F
06F4:  RRF    79,W
06F5:  ANDLW  30
06F6:  MOVWF  77
06F7:  MOVF   1D,W
06F8:  ANDLW  CF
06F9:  IORWF  77,W
06FA:  MOVWF  1D
....................    WHILE (TRUE)
....................    {
....................       output_high (PIN_D5);
06FB:  BSF    03.5
06FC:  BCF    08.5
06FD:  BCF    03.5
06FE:  BSF    08.5
....................       INT16 e = 0;
06FF:  CLRF   42
0700:  CLRF   41
....................       e = AVG_Index (FALSE);
0701:  CLRF   43
0702:  CALL   135
0703:  MOVF   79,W
0704:  MOVWF  42
0705:  MOVF   78,W
0706:  MOVWF  41
....................       PID (e);
0707:  MOVF   41,W
0708:  MOVWF  43
0709:  GOTO   592
....................       
....................       set_pwm1_duty (v_ref - PID_val);
070A:  MOVF   33,W
070B:  SUBWF  2E,W
070C:  MOVWF  43
070D:  MOVF   2F,W
070E:  MOVWF  44
070F:  MOVLW  00
0710:  BTFSS  03.0
0711:  MOVLW  01
0712:  SUBWF  44,F
0713:  RRF    44,F
0714:  RRF    43,F
0715:  RRF    44,F
0716:  RRF    43,F
0717:  RRF    44,F
0718:  MOVF   43,W
0719:  MOVWF  15
071A:  RRF    44,F
071B:  RRF    44,W
071C:  ANDLW  30
071D:  MOVWF  77
071E:  MOVF   17,W
071F:  ANDLW  CF
0720:  IORWF  77,W
0721:  MOVWF  17
....................       set_pwm2_duty (v_ref + PID_val);
0722:  MOVF   33,W
0723:  ADDWF  2E,W
0724:  MOVWF  43
0725:  MOVF   2F,W
0726:  MOVWF  44
0727:  BTFSC  03.0
0728:  INCF   44,F
0729:  RRF    44,F
072A:  RRF    43,F
072B:  RRF    44,F
072C:  RRF    43,F
072D:  RRF    44,F
072E:  MOVF   43,W
072F:  MOVWF  1B
0730:  RRF    44,F
0731:  RRF    44,W
0732:  ANDLW  30
0733:  MOVWF  77
0734:  MOVF   1D,W
0735:  ANDLW  CF
0736:  IORWF  77,W
0737:  MOVWF  1D
0738:  GOTO   6FB
....................    }
.................... }
.................... 
0739:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
